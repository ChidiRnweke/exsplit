package exsplit.expenseList
import exsplit.spec._
import cats.syntax.all._
import cats._
import cats.data._
import cats.effect._
import exsplit.circles._
import exsplit.expenses._
import exsplit.datamapper.circles._
import exsplit.datamapper.expenseList._
import exsplit.datamapper.expenses._
import exsplit.domainmapper._
import exsplit.datamapper.settledTabs._
import skunk.Session
import exsplit.database.AppSessionPool

/** Entry point for creating an instance of the ExpenseListService.
  */
object ExpenseListEntryPoint:
  /** Creates an ExpenseListService instance from the provided session. The
    * session pool is eventually passed down to involved repositories.
    *
    * @param session
    *   The AppSessionPool used for database operations.
    * @return
    *   An instance of ExpenseListService.
    */
  def fromSession[F[_]: Concurrent: Parallel](
      session: AppSessionPool[F]
  ): ExpenseListService[F] =
    val expenseListRepo = ExpenseListRepository.fromSession(session)
    val circleMembersRepo = CircleMembersRepository.fromSession(session)
    val expenseRepository = ExpenseRepository.fromSession(session)
    val circlesRepo = CirclesRepository.fromSession(session)
    val owedAmountsRepo = OwedAmountRepository.fromSession(session)
    val settledTabRepository = SettledTabRepository.fromSession(session)
    ExpenseListServiceImpl(
      expenseListRepo,
      circleMembersRepo,
      expenseRepository,
      circlesRepo,
      owedAmountsRepo,
      settledTabRepository
    )

/** The service trait for the expense list module. This trait is generated by
  * smithy4s. Each method maps to a route in the API. Authorization is not
  * included in this service, but is implemented in the
  * ExpenseListWithAuthEntryPoint.
  *
  * In case errors are thrown defined in the spec, they are caught and
  * transformed into the appropriate response by the error handling middleware
  * provided by smithy4s.
  *
  * Smithy4s also takes care of the deserialization of the request to the types
  * listed as input parameters as well as the serialization of the output types
  * to the response.
  */
case class ExpenseListServiceImpl[F[_]: MonadThrow: Parallel](
    expenseListRepo: ExpenseListRepository[F],
    circleMembersRepo: CircleMembersRepository[F],
    expenseRepository: ExpenseRepository[F],
    circlesRepo: CirclesRepository[F],
    owedAmountsRepo: OwedAmountRepository[F],
    settledTabRepository: SettledTabRepository[F]
) extends ExpenseListService[F]:

  /** Creates a new expense list for a circle.
    *
    * @param circleId
    *   The id of the circle the expense list is created for.
    * @param name
    *   The name of the expense list.
    * @return
    *   The created expense list.
    */
  def createExpenseList(
      circleId: CircleId,
      name: String
  ): F[CreateExpenseListOutput] =
    circlesRepo.withValidCircle(circleId) *>
      expenseListRepo
        .createExpenseList(circleId, name)
        .map(CreateExpenseListOutput(_))

  /** Get the details of an expense list. The onlyOutstanding parameter can be
    * used to filter out settled expenses.
    *
    * @param expenseListId
    *   The id of the expense list.
    * @param onlyOutstanding
    *   If true, only outstanding expenses are returned.
    * @return
    *   The details of the expense list.
    */
  def getExpenseList(
      expenseListId: ExpenseListId,
      onlyOutstanding: Option[Boolean]
  ): F[GetExpenseListOutput] =
    for
      expenseList <- expenseListRepo.getExpenseListDetail(
        expenseListId,
        expenseRepository,
        owedAmountsRepo,
        circleMembersRepo
      )
      filtered = handleOutStandingFilter(expenseList, onlyOutstanding)
    yield GetExpenseListOutput(filtered)

  private def handleOutStandingFilter(
      expenseList: ExpenseListDetailOut,
      onlyOutstanding: Option[Boolean]
  ): ExpenseListDetailOut =
    def filterOutStanding(expenseList: ExpenseListDetailOut) =
      expenseList.copy(totalOwed = expenseList.totalOwed.filter(_.amount > 0))

    onlyOutstanding match
      case Some(true) =>
        filterOutStanding(expenseList)
      case _ =>
        expenseList

  /** Get the settled expenses for an expense list. This includes the expenses
    * that have been settled between members.
    *
    * @param expenseListId
    *   The id of the expense list.
    * @return
    *   The settled expenses for the expense list.
    */
  def getSettledExpenseLists(
      expenseListId: ExpenseListId
  ): F[GetSettledExpenseListsOutput] =
    for
      _ <- expenseListRepo.withValidExpenseList(expenseListId)
      tabs <- settledTabRepository.getSettledTabs(
        expenseListId,
        circleMembersRepo
      )
      settledTabsOut = SettledTabsOut(tabs)
    yield GetSettledExpenseListsOutput(settledTabsOut)

  /** Settle an expense list between two members. This creates a settled tab
    * between the two members.
    * @param expenseListId
    *   The id of the expense list.
    * @param fromMemberId
    *   The id of the member who paid the expense.
    * @param toMemberId
    *   The id of the member who owes the expense.
    * @param amount
    *   The amount to settle.
    */
  def settleExpenseList(
      expenseListId: ExpenseListId,
      fromMemberId: CircleMemberId,
      toMemberId: CircleMemberId,
      amount: Amount
  ): F[Unit] =
    (
      expenseListRepo.withValidExpenseList(expenseListId),
      circleMembersRepo.withValidCircleMember(fromMemberId),
      circleMembersRepo.withValidCircleMember(toMemberId)
    ).parTupled *>
      settledTabRepository
        .create(expenseListId, fromMemberId, toMemberId, amount)
        .void

  /** Delete an expense list. This will also delete all expenses associated with
    * the expense list.
    *
    * @param id
    *   The id of the expense list.
    * @return
    *   Unit
    */
  def deleteExpenseList(id: ExpenseListId): F[Unit] =
    expenseListRepo.withValidExpenseList(id) *> expenseListRepo.delete(id)

  /** Get all expense lists for a circle. This includes the total amount owed
    * for each expense list. The total amount owed is the sum of all expenses
    * minus the sum of all settled expenses.
    *
    * @param circleId
    *   The id of the circle.
    * @return
    *   The expense lists for the circle.
    */
  def getExpenseLists(circleId: CircleId): F[GetExpenseListsOutput] =
    circlesRepo.withValidCircle(circleId) *>
      expenseListRepo
        .byCircleId(circleId)
        .map(_.toExpenseListOuts)
        .map(lists => GetExpenseListsOutput(ExpenseListsOut(lists)))

  /** Update the name of an expense list.
    *
    * @param id
    *   The id of the expense list.
    * @param name
    *   The new name of the expense list.
    * @return
    *   Unit
    */
  def updateExpenseList(id: ExpenseListId, name: String): F[Unit] =
    val write = ExpenseListWriteMapper(id.value, name)
    expenseListRepo.withValidExpenseList(id) *> expenseListRepo.update(write)

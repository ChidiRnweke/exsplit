package exsplit.circles

import exsplit.spec._
import cats.effect._
import cats.syntax.all._
import cats._
import cats.data._
import exsplit.auth._
import exsplit.circles._
import exsplit.datamapper.user._
import exsplit.datamapper.circles._
import skunk.Session
import exsplit.domainmapper._
import exsplit.authorization.extractors._
import exsplit.authorization._
import exsplit.database.AppSessionPool

/** Entry point for creating an instance of the CirclesService.
  */
object CirclesEntryPoint:
  /** Creates a CirclesService instance from the provided session. The session
    * pool is eventually passed down to involved repositories.
    *
    * @param pool
    *   The AppSessionPool used for database operations.
    * @return
    *   An instance of CirclesService.
    */
  def fromSession[F[_]: Concurrent: Parallel](
      pool: AppSessionPool[F]
  ): CirclesService[F] =

    val circlesRepo = CirclesRepository.fromSession(pool)
    val membersRepo = CircleMembersRepository.fromSession(pool)
    val userRepo = UserMapper.fromSession(pool)
    CirclesServiceImpl(circlesRepo, membersRepo, userRepo)

/** Implementation of the CirclesService trait. The trait is generated by
  * smithy4s. Each method maps to a route in the API. Authorization is not
  * included in this service, but is implemented in the
  * CirclesWithAuthEntryPoint.
  *
  * In case errors are thrown defined in the spec, they are caught and
  * transformed into the appropriate response by the error handling middleware
  * provided by smithy4s.
  *
  * Smithy4s also takes care of the deserialization of the request to the types
  * listed as input parameters as well as the serialization of the output types
  * to the response.
  *
  * @param circlesRepo
  * @param circleMembersRepo
  * @param userRepo
  */
case class CirclesServiceImpl[F[_]: MonadThrow: Parallel](
    circlesRepo: CirclesRepository[F],
    circleMembersRepo: CircleMembersRepository[F],
    userRepo: UserMapper[F]
) extends CirclesService[F]:
  /** Lists all circles for a user.
    *
    * @param userId
    *   The unique identifier of the user.
    * @return
    *   A list of circles.
    */
  def listCirclesForUser(userId: UserId): F[CirclesOut] =
    withValidUser(userId, userRepo) *> circlesRepo.getCirclesOut(userId)

  /** Removes a member from a circle.
    *
    * If the member is the last member of the circle, the circle is deleted.
    *
    * @param circleId
    *   The unique identifier of the circle.
    * @param member
    *   The unique identifier of the member.
    * @return
    *   A `Unit` indicating the completion of the operation.
    */
  def removeMemberFromCircle(
      circleId: CircleId,
      member: CircleMemberId
  ): F[Unit] =
    for
      _ <- circlesRepo.withValidCircle(circleId)
      _ <- circleMembersRepo.delete(member)
      // TODO: the user is not allowed to have outstanding debts in the circle
      members <- circleMembersRepo.getCircleMembersOuts(circleId)
      _ <- deleteCircleIfEmpty(circleId, members)
    yield ()

  /** Retrieves a circle by its unique identifier.
    * @param circleId
    *   The unique identifier of the circle.
    * @return
    *   The circle.
    */
  def getCircle(circleId: CircleId): F[GetCircleOutput] =
    circlesRepo.getCircleOut(circleId).map(GetCircleOutput(_))

  /** Changes the display name of a circle member.
    * @param circleId
    *   The unique identifier of the circle.
    * @param memberId
    *   The unique identifier of the member.
    * @param displayName
    * @return
    */
  def changeDisplayName(
      circleId: CircleId,
      memberId: CircleMemberId,
      displayName: String
  ): F[Unit] =
    val write = CircleMemberWriteMapper(memberId.value, displayName)

    (
      circleMembersRepo.withValidCircleMember(memberId),
      circlesRepo.withValidCircle(circleId)
    ).parTupled *> circleMembersRepo.update(write)

  /** Creates a circle and adds the user that made it to the circle as a member.
    *
    * @param userId
    *   The unique identifier of the user.
    * @param displayName
    *   The display name of the eventual circle member.
    * @param circleName
    *   The name of the circle.
    * @param description
    *   An optional description of the circle.
    * @return
    *   The created circle.
    */
  def createCircle(
      userId: UserId,
      displayName: String,
      circleName: String,
      description: Option[String]
  ): F[CreateCircleOutput] =
    for
      _ <- withValidUser(userId, userRepo)
      circle <- circlesRepo
        .createCircle(userId, displayName, circleName, description)
      circleId = CircleId(circle.circleId)
      _ <- circleMembersRepo.addCircleMember(userId, displayName, circleId)
    yield CreateCircleOutput(circle)

  /** Adds a user to a circle as a circle member.
    * @param user
    *   The unique identifier of the user to add.
    * @param displayName
    *   The display name of the user in the circle.
    * @param circleId
    *   The unique identifier of the circle.
    * @return
    *   A `Unit` indicating the completion of the operation.
    */

  def addUserToCircle(
      user: UserId,
      displayName: String,
      circleId: CircleId
  ): F[Unit] =
    (
      withValidUser(user, userRepo),
      circlesRepo.withValidCircle(circleId)
    ).parTupled *>
      circleMembersRepo.addCircleMember(user, displayName, circleId).void

  /** Deletes a circle. additional checks may be added in the future.
    *
    * @param circleId
    *   The unique identifier of the circle.
    * @return
    *   A `Unit` indicating the completion of the operation.
    */
  def deleteCircle(circleId: CircleId): F[Unit] =
    // TODO: the circle is not allowed to have outstanding debts
    circlesRepo.delete(circleId)

  def listCircleMembers(circleId: CircleId): F[MembersListOut] =
    circlesRepo.withValidCircle(circleId) *>
      circleMembersRepo.getCircleMembersOuts(circleId).map(MembersListOut(_))

  /** Updates a circle. The name, description or both can be updated.
    *
    * @param circleId
    *   The unique identifier of the circle.
    * @param name
    *   The new name of the circle.
    * @param description
    *   The new description of the circle.
    * @return
    *   A `Unit` indicating the completion of the operation.
    */
  def updateCircle(
      circleId: CircleId,
      name: Option[String],
      description: Option[String]
  ): F[Unit] =
    circlesRepo.withValidCircle(circleId) *>
      circlesRepo.update(CircleWriteMapper(circleId.value, name, description))

  private def deleteCircleIfEmpty(
      circleId: CircleId,
      members: List[CircleMemberOut]
  ): F[Unit] =
    members match
      case Nil => circlesRepo.delete(circleId)
      case _   => ().pure[F]

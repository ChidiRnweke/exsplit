package exsplit.expenses

import exsplit.spec._
import cats.syntax.all._
import cats.data._
import cats._
import cats.effect._
import smithy4s.Timestamp
import exsplit.expenseList._
import exsplit.datamapper.expenses._
import exsplit.datamapper.circles._
import exsplit.datamapper.expenseList._
import exsplit.domainmapper._
import java.time.LocalDate
import skunk.Session
import exsplit.database.AppSessionPool

/** Entry point for creating an instance of the ExpenseService.
  */
object ExpensesEntryPoint:
  /*
   * Creates an ExpenseService instance from the provided session. The session
   * pool is eventually passed down to involved repositories.
   *
   * @param session
   *  The AppSessionPool used for database operations.
   */
  def fromSession[F[_]: Concurrent: Parallel](
      session: AppSessionPool[F]
  ): ExpenseService[F] =
    val expenseRepo = ExpenseRepository.fromSession(session)
    val expenseListRepo = ExpenseListRepository.fromSession(session)
    val membersRepo = CircleMembersRepository.fromSession(session)
    val owedAmountRepo = OwedAmountRepository.fromSession(session)
    ExpenseServiceImpl(
      expenseRepo,
      expenseListRepo,
      membersRepo,
      owedAmountRepo
    )

/** The service trait for the expenses module. This trait is generated by
  * smithy4s. Each method maps to a route in the API. Authorization is not
  * included in this service, but is implemented in the
  * ExpensesWithAuthEntryPoint.
  *
  * In case errors are thrown defined in the spec, they are caught and
  * transformed into the appropriate response by the error handling middleware
  * provided by smithy4s.
  *
  * Smithy4s also takes care of the deserialization of the request to the types
  * listed as input parameters as well as the serialization of the output types
  * to the response.
  */
case class ExpenseServiceImpl[F[_]: MonadThrow: Parallel](
    expenseRepo: ExpenseRepository[F],
    expenseListRepo: ExpenseListRepository[F],
    membersRepo: CircleMembersRepository[F],
    owedAmountRepo: OwedAmountRepository[F]
) extends ExpenseService[F]:

  /** Creates an expense in the database. The expense is associated with an
    * expense list and is paid by a circle member. The expense can be split
    * between multiple members.
    *
    * @param expenseListId
    *   The id of the expense list the expense is associated with.
    * @param paidBy
    *   The id of the circle member who paid for the expense.
    * @param description
    *   The description of the expense.
    * @param price
    *   The price of the expense.
    * @param date
    *   The date the expense was made.
    * @param owedToPayer
    *   A list of the amounts owed to the payer by other members. It is an array
    *   that contains the circle member id and the amount owed to the payer.
    * @return
    */
  def createExpense(
      expenseListId: ExpenseListId,
      paidBy: CircleMemberId,
      description: String,
      price: Amount,
      date: Timestamp,
      owedToPayer: List[OwedAmount]
  ): F[CreateExpenseOutput] =
    val input = CreateExpenseInput(
      expenseListId,
      paidBy,
      description,
      price,
      date,
      owedToPayer
    )
    def createExpenseHelper(
        exp: ExpenseReadMapper,
        member: CircleMemberOut
    ): F[CreateExpenseOutput] =
      val expenseId = ExpenseId(exp.id)
      val amounts = owedToPayer.map: o =>
        CreateOwedAmountInput(expenseId, o.circleMemberId, paidBy, o.amount)

      for
        _ <- amounts.parTraverse(owedAmountRepo.create)
        owed <- owedAmountRepo.getOwedAmounts(expenseId)
        out = ExpenseOut(exp.id, member, exp.description, exp.price, date, owed)
      yield CreateExpenseOutput(out)

    expenseListRepo.withValidExpenseList(expenseListId) *>
      (expenseRepo.create(input), membersRepo.getCircleMemberOut(paidBy))
        .parFlatMapN(createExpenseHelper)

  /** Returns a list of expenses associated with an expense list.
    *
    * @param id
    *   The id of the expense list.
    * @return
    *   A list of expenses associated with the expense list.
    */
  def getExpense(id: ExpenseId): F[GetExpenseOutput] =
    expenseRepo
      .getExpenseOut(id, owedAmountRepo)
      .map(GetExpenseOutput(_))

  /** Returns a list of expenses associated with an expense list.
    *
    * @param id
    *   The id of the expense list.
    * @return
    *   A list of expenses associated with the expense list.
    */
  def deleteExpense(id: ExpenseId): F[Unit] =
    expenseRepo.delete(id)

  /** Updates an expense in the database. You can update any combination of the
    * following fields: paidBy, description, price, date, owedToPayer.
    *
    * @param id
    *   The id of the expense to update.
    * @param paidBy
    *   The id of the circle member who paid for the expense.
    * @param description
    *   The description of the expense.
    * @param price
    *   The price of the expense.
    * @param date
    *   The date the expense was made.
    * @param owedToPayer
    *   A list of the amounts owed to the payer by other members. It is an array
    *   that contains the circle member id and the amount owed to the payer. The
    *   entire list of owed amounts is replaced with the new list.
    * @return
    *   Unit
    */
  def updateExpense(
      id: ExpenseId,
      paidBy: Option[CircleMemberId],
      description: Option[String],
      price: Option[Amount],
      date: Option[Timestamp],
      owedToPayer: Option[List[OwedAmount]]
  ): F[Unit] =
    val expenseWriter = ExpenseWriteMapper(
      id.value,
      paidBy.map(_.value),
      description,
      price.map(_.value),
      date
    )

    expenseRepo.update(expenseWriter)
